<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>アークナイツ キャラ検索</title>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-main: #e0e0e0;
            --text-sub: #a0a0a0;
            --accent: #00d2ff;
            --accent-hover: #00aadd;
            --border: #333;
            --active-bg: #00d2ff;
            --active-text: #000;
            --toggle-bg-and: #ff9800; /* AND検索時の色 */
            --toggle-bg-or: #4caf50;  /* OR検索時の色 */
        }

        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
        }

        h1 {
            border-left: 5px solid var(--accent);
            padding-left: 15px;
            margin-bottom: 20px;
        }

        /* 検索フィルタエリア */
        .filter-container {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 4px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        .filter-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .filter-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        /* ヘッダー周り（ラベルとスイッチ） */
        .group-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 15px;
        }

        .filter-label {
            font-weight: bold;
            color: var(--accent);
            font-size: 0.95rem;
            min-width: 80px;
        }

        /* AND/OR トグルスイッチ */
        .logic-toggle {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
            user-select: none;
        }
        
        /* ORモード */
        .logic-toggle[data-mode="OR"] {
            background-color: var(--card-bg);
            border-color: var(--toggle-bg-or);
            color: var(--toggle-bg-or);
        }
        .logic-toggle[data-mode="OR"]:before { content: "● OR (選択したいずれかの要素を持つ)"; }
        
        /* ANDモード */
        .logic-toggle[data-mode="AND"] {
            background-color: var(--card-bg);
            border-color: var(--toggle-bg-and);
            color: var(--toggle-bg-and);
        }
        .logic-toggle[data-mode="AND"]:before { content: "● AND (選択したすべての要素を持つ)"; }

        /* フィルタボタン */
        .btn-filter {
            background-color: transparent;
            border: 1px solid #555;
            color: var(--text-sub);
            padding: 6px 12px;
            margin: 0 6px 6px 0;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .btn-filter:hover {
            border-color: var(--accent);
            color: var(--text-main);
        }

        .btn-filter.active {
            background-color: var(--active-bg);
            color: var(--active-text);
            border-color: var(--active-bg);
            font-weight: bold;
        }

        /* 結果表示エリア */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px 0;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }

        .btn-reset {
            background-color: #d32f2f;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 2px;
            cursor: pointer;
            font-weight: bold;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
        }

        /* キャラクターカード */
        .char-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 15px;
            text-decoration: none;
            color: inherit;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
        }

        .char-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            border-color: var(--accent);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
            margin-bottom: 10px;
        }

        .char-name { font-size: 1.1rem; font-weight: bold; color: var(--text-main); }
        .char-sub { font-size: 0.8rem; color: var(--text-sub); background: #333; padding: 2px 6px; border-radius: 2px; }
        
        .char-tags { margin-bottom: 12px; font-size: 0.75rem; color: #888; }
        .tag-badge { display: inline-block; border: 1px solid #555; padding: 1px 5px; margin-right: 3px; margin-bottom: 3px; border-radius: 2px; }

        .char-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px 10px; font-size: 0.85rem; }
        .stat-item { display: flex; justify-content: space-between; }
        .stat-label { color: #777; }
        .stat-val { color: #ccc; }
        .bonus { color: var(--accent); font-size: 0.8em; margin-left: 2px; }

        .loading-msg { text-align: center; font-size: 1.2rem; color: var(--text-sub); margin-top: 50px; }
        
        .empty-branch-msg { color: #666; font-style: italic; font-size: 0.9rem; padding: 5px 0; }
    </style>
</head>
<body>

    <h1>アークナイツ キャラクターデータベース</h1>

    <div id="loading" class="loading-msg">データベースを読み込み中...</div>

    <div id="main-content" style="display:none;">
        <div class="filter-container">
            
            <!-- 職業 -->
            <div class="filter-group">
                <div class="group-header">
                    <span class="filter-label">職業</span>
                    <!-- 職業は単一属性なのでAND検索(複数選択)すると結果0になるが、一応切り替え可能にする -->
                    <button class="logic-toggle" id="toggle-profession" data-mode="OR" onclick="toggleLogic('profession')"></button>
                </div>
                <div id="btns-profession"></div>
            </div>

            <!-- 職分 (職業選択後に表示) -->
            <div class="filter-group">
                <div class="group-header">
                    <span class="filter-label">職分</span>
                    <button class="logic-toggle" id="toggle-branch" data-mode="OR" onclick="toggleLogic('branch')"></button>
                </div>
                <div id="btns-branch">
                    <div class="empty-branch-msg">職業を選択すると、対応する職分が表示されます</div>
                </div>
            </div>

            <!-- ブロック数 -->
            <div class="filter-group">
                <div class="group-header">
                    <span class="filter-label">ブロック数</span>
                    <button class="logic-toggle" id="toggle-block_count" data-mode="OR" onclick="toggleLogic('block_count')"></button>
                </div>
                <div id="btns-block"></div>
            </div>

            <!-- 入手方法 -->
            <div class="filter-group">
                <div class="group-header">
                    <span class="filter-label">入手方法</span>
                    <button class="logic-toggle" id="toggle-obtain_method" data-mode="OR" onclick="toggleLogic('obtain_method')"></button>
                </div>
                <div id="btns-obtain"></div>
            </div>

            <!-- 募集タグ -->
            <div class="filter-group">
                <div class="group-header">
                    <span class="filter-label">公開求人募集タグ</span>
                    <!-- デフォルトをAND検索に設定 -->
                    <button class="logic-toggle" id="toggle-tags" data-mode="AND" onclick="toggleLogic('tags')"></button>
                </div>
                <div id="btns-tags"></div>
            </div>

        </div>

        <div class="status-bar">
            <span id="result-count" style="font-weight:bold; font-size:1.1rem;">Loading...</span>
            <button class="btn-reset" onclick="resetAll()">条件をリセット</button>
        </div>

        <div id="results" class="results-grid"></div>
    </div>

    <script>
        let allCharacters = [];
        let structuredData = {};
        
        // フィルタ選択状態
        let filters = {
            profession: [],
            branch: [],
            block_count: [],
            obtain_method: [],
            tags: []
        };

        // 検索ロジック状態 (AND / OR)
        let filterLogics = {
            profession: 'OR',
            branch: 'OR',
            block_count: 'OR',
            obtain_method: 'OR',
            tags: 'AND' // タグのみデフォルトAND
        };

        window.addEventListener('DOMContentLoaded', async () => {
            try {
                const [charsRes, structRes] = await Promise.all([
                    fetch('arknights_characters.json'),
                    fetch('arknights_structured_values.json')
                ]);

                if (!charsRes.ok || !structRes.ok) throw new Error("Load failed");

                allCharacters = await charsRes.json();
                structuredData = await structRes.json();

                initStaticButtons();
                updateResults(); // 初回描画

                document.getElementById('loading').style.display = 'none';
                document.getElementById('main-content').style.display = 'block';

            } catch (error) {
                document.getElementById('loading').textContent = "JSON読み込みエラー。サーバー経由で開いてください。";
                console.error(error);
            }
        });

        // 職業・ブロック・入手・タグのボタン生成（職分以外）
        function initStaticButtons() {
            // 職業
            const profContainer = document.getElementById('btns-profession');
            const professions = Object.keys(structuredData.profession_branches || {}).sort();
            professions.forEach(p => createButton(profContainer, 'profession', p));

            // ブロック
            const blockContainer = document.getElementById('btns-block');
            (structuredData.block_counts || []).forEach(v => createButton(blockContainer, 'block_count', v));

            // 入手方法
            const obtainContainer = document.getElementById('btns-obtain');
            (structuredData.obtain_methods || []).forEach(v => createButton(obtainContainer, 'obtain_method', v));

            // タグ
            const tagsContainer = document.getElementById('btns-tags');
            (structuredData.tags || []).forEach(v => createButton(tagsContainer, 'tags', v));
        }

        // 汎用ボタン生成
        function createButton(container, type, value) {
            const btn = document.createElement('button');
            btn.className = 'btn-filter';
            btn.textContent = value;
            btn.dataset.type = type;
            btn.dataset.value = value;
            
            // 既に選択済みならアクティブ化（リセット後などの再生成時用）
            if (filters[type].includes(value)) {
                btn.classList.add('active');
            }
            
            btn.addEventListener('click', function() {
                toggleFilter(type, value, this);
            });
            container.appendChild(btn);
        }

        // フィルタON/OFF
        function toggleFilter(type, value, btnElement) {
            const index = filters[type].indexOf(value);
            if (index === -1) {
                filters[type].push(value);
                btnElement.classList.add('active');
            } else {
                filters[type].splice(index, 1);
                btnElement.classList.remove('active');
            }

            // 職業が変更された場合、職分ボタンを更新する
            if (type === 'profession') {
                updateBranchButtons();
            }

            updateResults();
        }

        // 職分ボタンの動的更新
        function updateBranchButtons() {
            const container = document.getElementById('btns-branch');
            const selectedProfs = filters.profession;

            // コンテナをクリア
            container.innerHTML = '';

            // 職業が選択されていない場合
            if (selectedProfs.length === 0) {
                filters.branch = []; // 職分選択もクリア
                container.innerHTML = '<div class="empty-branch-msg">職業を選択すると、対応する職分が表示されます</div>';
                return;
            }

            // 選択された職業に対応する職分リストを作成
            let availableBranches = [];
            selectedProfs.forEach(prof => {
                const branches = structuredData.profession_branches[prof] || [];
                availableBranches = availableBranches.concat(branches);
            });
            
            // 重複削除とソート
            availableBranches = [...new Set(availableBranches)].sort();

            // 現在選択中の職分が、新しいリストに含まれていなければ選択解除する
            filters.branch = filters.branch.filter(b => availableBranches.includes(b));

            // ボタン生成
            availableBranches.forEach(br => {
                createButton(container, 'branch', br);
            });
        }

        // AND/OR 切り替え
        function toggleLogic(type) {
            const current = filterLogics[type];
            const next = current === 'OR' ? 'AND' : 'OR';
            filterLogics[type] = next;

            // ボタン表示更新
            const btn = document.getElementById(`toggle-${type}`);
            btn.dataset.mode = next;

            updateResults();
        }

        // 検索実行
        function updateResults() {
            const resultsContainer = document.getElementById('results');
            const countLabel = document.getElementById('result-count');
            
            const filteredChars = allCharacters.filter(char => {
                return checkCategory(char, 'profession', char.profession) &&
                       checkCategory(char, 'branch', char.branch) &&
                       checkCategory(char, 'block_count', char.block_count) &&
                       checkCategory(char, 'obtain_method', char.obtain_method) &&
                       checkCategory(char, 'tags', char.tags); // tagsは配列
            });

            countLabel.textContent = `検索結果: ${filteredChars.length} 件`;
            renderCards(filteredChars, resultsContainer);
        }

        // 各カテゴリの判定ロジック
        function checkCategory(char, type, charValue) {
            const selectedValues = filters[type];
            const logic = filterLogics[type]; // 'AND' or 'OR'

            // 何も選択されていなければフィルタしない（通過）
            if (selectedValues.length === 0) return true;

            // キャラ側の値が配列の場合（Tagsなど）
            if (Array.isArray(charValue)) {
                if (logic === 'AND') {
                    // 選択した全てを持っているか
                    return selectedValues.every(val => charValue.includes(val));
                } else {
                    // 選択したもののうちどれか一つでも持っているか
                    return selectedValues.some(val => charValue.includes(val));
                }
            } 
            // キャラ側の値が単一の場合（職業、職分など）
            else {
                if (logic === 'AND') {
                    // 単一値に対してAND検索（複数選択）すると、値は一つしか持てないので
                    // 選択肢が2つ以上の場合は必ずfalseになる
                    if (selectedValues.length > 1) return false;
                    return selectedValues.includes(charValue);
                } else {
                    // OR検索（どれかに一致）
                    return selectedValues.includes(charValue);
                }
            }
        }

        // カード描画
        function renderCards(chars, container) {
            if (chars.length === 0) {
                container.innerHTML = '<div style="grid-column:1/-1; text-align:center; color:#777;">該当するキャラクターはいません</div>';
                return;
            }

            let html = '';
            chars.forEach(char => {
                const tagsHtml = (char.tags || []).map(t => `<span class="tag-badge">${t}</span>`).join('');
                
                // 数値データの整形
                let atk = char.attack ? char.attack.base : '-';
                if (char.attack && char.attack.trust_bonus) atk += `<span class="bonus">${char.attack.trust_bonus}</span>`;
                
                let def = char.defense ? char.defense.base : '-';
                if (char.defense && char.defense.trust_bonus) def += `<span class="bonus">${char.defense.trust_bonus}</span>`;
                
                const redeploy = (char.redeploy_time || '-').split(' ')[0];

                html += `
                <a href="${char.url}" target="_blank" class="char-card">
                    <div class="card-header">
                        <span class="char-name">${char.name}</span>
                        <span class="char-sub">${char.profession}</span>
                    </div>
                    <div class="char-tags">
                        <div>職分: ${char.branch}</div>
                        <div style="margin-top:4px;">${tagsHtml}</div>
                    </div>
                    <div class="char-stats-grid">
                        <div class="stat-item"><span class="stat-label">HP</span><span class="stat-val">${char.hp ? char.hp.base : '-'}</span></div>
                        <div class="stat-item"><span class="stat-label">攻撃</span><span class="stat-val">${atk}</span></div>
                        <div class="stat-item"><span class="stat-label">防御</span><span class="stat-val">${def}</span></div>
                        <div class="stat-item"><span class="stat-label">コスト</span><span class="stat-val">${char.cost}</span></div>
                        <div class="stat-item"><span class="stat-label">ブロック</span><span class="stat-val">${char.block_count}</span></div>
                        <div class="stat-item"><span class="stat-label">再配置</span><span class="stat-val">${redeploy}</span></div>
                    </div>
                </a>
                `;
            });
            container.innerHTML = html;
        }

        // リセット
        function resetAll() {
            filters = { profession: [], branch: [], block_count: [], obtain_method: [], tags: [] };
            
            // ロジックはリセットしない方が親切かもしれないが、一応デフォルトに戻すなら以下
            filterLogics = { profession: 'OR', branch: 'OR', block_count: 'OR', obtain_method: 'OR', tags: 'AND' };
            
            // UI更新
            document.querySelectorAll('.logic-toggle').forEach(btn => {
                const type = btn.id.replace('toggle-', '');
                btn.dataset.mode = filterLogics[type];
            });

            document.querySelectorAll('.btn-filter.active').forEach(btn => btn.classList.remove('active'));
            
            updateBranchButtons(); // 職分エリアをリセット（空にする）
            updateResults();
        }
    </script>
</body>
</html>
